#
#
# ---------------------------------------------------------------------------
# Database Editor/Viewer for epic5's $dbmctl() 
# ---------------------------------------------------------------------------
#
# Written by tjh 2012 - tim@muppetz.com
#
# Much help and guidance from #epic on efnet.  Couldn't have written this
# without the help of hop, caf, CrazyEddy & many other helpful friendly souls
# in there. Thanks!
#
# PS: Yea, it looks like fortran. I learnt this craft from srfrog - Blame him.
#
IF (word(2 $loadinfo()) != [pf]) {
  LOAD -pf $word(1 $loadinfo());
  RETURN;
};
XECHO;
XECHO +--------------------------------------------------------+;
XECHO Database Editor for EPIC5's $$dbmctl command;
XECHO;
XECHO /dbfile		- Load/change database files;
XECHO /dblist		- Database list/search commands;
XECHO /dbedit		- Database editing commands;

# This routine loads the database file and assigns the file descriptor.
# We also mark that we have a database open using db.loaded so we can check
# before performing any operations.  The path to the open database is stored in
# db.file.  This routine won't let you open a database that doesn't exist, use
# dbcreate for that.
#
ALIAS dbfile {
  IF ([$0] == [-c]) {
    UNLESS (db.loaded) {
      XECHO -B You don't have a database open.;
      RETURN;
    };
    @ dbmctl(CLOSE $db.fd);
    @ db.loaded = 0;
    XECHO -B Closed database $db.file;
    RETURN;
  };
  IF (db.loaded) {@ :db.old = db.file};
  UNLESS (@) {
    XECHO;
    IF (db.loaded) {XECHO -B Database Open: $db.file};
    XECHO -B To load/change a database:  /dbfile <filename>;
    XECHO -B To close the open database: /dbfile -c;
  }{
    @ db.file = [$0];
    UNLESS (fexist(${db.file ## [.pag]}) ==1) {
      XECHO -B Sorry $db.file doesn't exist!;
      RETURN;
      };
    IF (db.loaded) {
      @ dbmctl(CLOSE $db.fd);
      XECHO -B Closed $db.old;
    };
    @ db.fd = dbmctl(OPEN STD $db.file);
    UNLESS (db.fd == -1) {
      XECHO -B $db.file loaded. \(Using file descriptor $db.fd\);
      @ db.loaded = 1;
    }{
      XECHO -B Error! Can't open $db.file - Please check this file is valid;
    };
  };
};

# This routine lets you edit/change/delete and create database variables.  
# Which is kinda useful really for an "editor" right?
ALIAS dbedit {
  UNLESS (db.loaded) {XECHO Please load a database first using /dbfile;RETURN};
  UNLESS (([$0]) && ([$1])) {
    XECHO -B Usage: /dbedit <option>;
    XECHO -B;
    XECHO -B  -c <variable>  Create <variable>;
    XECHO -B  -e <variable>  Edit the contents of <variable>;
    XECHO -B  -r <variable>  Rename <variable>;
    XECHO -B  -d <variable>  Delete <variable>;
    RETURN;
  };
  UNLESS (finddb($1) && ($0 != [-c])) {XECHO ERROR: $1 doesn't exist in the database;RETURN};
  @ dbvar = [$1];
  @ dbval = dbmctl(READ $db.fd $1); 
  SWITCH ($0) {
    (-e)  {
      INPUT "New value for $1: " {
        IF (@ && [$*] != [$dbval]) {
          @ dbmctl(CHANGE $db.fd $dbvar $*);
          XECHO $dbvar changed to: $*;
        }{
          XECHO $dbvar unchanged;
        };
      };
      XTYPE -literal $dbmctl(READ $db.fd $dbvar);
    };
    (-d)  {@ dbmctl(DELETE $db.fd $dbvar); XECHO $dbvar Deleted;}
    (-c)  {
      INPUT "New value for new variable $1: " {
          @ dbmctl(ADD $db.fd $dbvar $*);
          XECHO $dbvar created with value: $*;
        };
      };
    (-r) {
      INPUT "Rename $1 to: " {
        @dbmctl(ADD $db.fd $0 $dbmctl(READ $db.fd $dbvar));
        @dbmctl(DELETE $db.fd $dbvar);
        XECHO $dbvar renamed to: $0;
      };
    };    
  };
};

# This routine resets the database to the start and loops over them all returning
# their values.  The dump is completed when the next read of the database returns
# null.  Some filtering/search capabilities are included, these still loop over
# the whole database as there's no way to search within in.
#
ALIAS dblist {
  UNLESS (db.loaded) {XECHO Please load a database first using /dbfile;RETURN};
  UNLESS (@) {
    XECHO -B Usage: /db <option>;
    XECHO -B;
    XECHO -B  -k         List all database variables.;
    XECHO -B  -a         List all database variables and contents.;
    XECHO -B  -f <text>  Find variable names containing <text>;
    XECHO -B  -d <text>  Find variable contents containing <text>;
    XECHO -B  -ac        List all database variables and contents, stripped of control chars;
    XECHO -B  -fa <text> Find variable names containing <text>, stripped of control chars;
    XECHO;
    RETURN;
  };
  XECHO;
  XECHO $repeat(15  ) [Database: $db.file];
  @ :endfile = :position = :matchcount = 0;
  XECHO Variable $repeat(37  ) Value;
  XECHO $repeat(70 =);
  WHILE (endfile != 1) {
    IF (position == 0)  {
      @ item = dbmctl(NEXT_KEY $db.fd 1);
    }{
      @ item = dbmctl(NEXT_KEY $db.fd 0);
    };
    @ position++;
    @ itemdata = dbmctl(READ $db.fd $item);
    UNLESS (item) {
      @ endfile = 1;
      @ position--;
      XECHO $repeat(70 =);
      IF (matchcount == 0) {XECHO Nothing found!}{XECHO Total Items: $matchcount};
    }{
      SWITCH ($0) {
        (-a) 	{ XECHO $item $repeat(${45 - strlen($item)}  ) $itemdata; @ matchcount++};
	(-k)  	{ XECHO $item; @ matchcount++};
        (-ac) 	{ XECHO $stripcrap(ALL $item) $repeat(${45 - strlen($item)}  ) $stripcrap(ALL $itemdata); @ matchcount++};
        (-f) 	{ IF (match(*$1* $item)) {XECHO $item $repeat(${45 - strlen($item)}  ) $itemdata; @ matchcount++}};
        (-fa) 	{ IF (match(*$1* $stripcrap(ALL $itemdata))) {XECHO $stripcrap(ALL $item) $repeat(${45 - strlen($item)}  ) $stripcrap(ALL $itemdata); @ matchcount++}};
        (-d) 	{ IF (match(*$1* $itemdata)) {XECHO $item $repeat(${45 - strlen($item)}  ) $itemdata; @ matchcount++}};
        (*) 	{ XECHO Unsupported flag;RETURN};
      };
    };
  };
};

# We walk through the database looking for $query
# If we find it exactly, we return 1 to the calling
# function.  Lets you confirm a variable name exists.
ALIAS finddb (query) {
  @ :endfile = :position = 0;
  WHILE (endfile != 1) {
    IF (position == 0)  {
      @ item = dbmctl(NEXT_KEY $db.fd 1);
    }{
      @ item = dbmctl(NEXT_KEY $db.fd 0);
    };
    @ position++;
    IF ([$item] == [$query]) {RETURN 1};
    UNLESS (item) {
      @ endfile = 1;
      @ position--;
      };
    };
  };
};

#tjh/12
