#
#   IRC Script Program. For use with ircii-EPIC5 clients.
#   Copyright (C) 2000 SrfRoG (cag@codehack.com)
#
# ---------------------------------------------------------------------------
# lice.db written by tjh for LiCe5.2.0+ for EPIC5. tjh - tim@muppetz.com
#
# This file opens the database file in which variables are stored and creates
# some aliases to easily manage the variables in the DB.
#
# Autosave of system settings is handled by this file.
#
# http://lice.muppetz.com - LiCe5
# ---------------------------------------------------------------------------
#

IF (word(2 $loadinfo()) != [pf]) {
  LOAD -pf $word(1 $loadinfo());
  RETURN;
};

PACKAGE LiCe;

@ mkdir($lice.save_path);

# open database
@ lice.fd = dbmctl(OPEN STD $(lice.save_path)/lice.db);

# check we got the db open and if not, die.
IF (lice.fd == -1) {
  CLEAR;
  xECHO;
  XECHO [LiCe System Message];
  XECHO;
  XECHO ERROR: Unable to open $(lice.save_path)/lice.db - Please check this path is valid!;
  XECHO ;
  XECHO Unable to continue.
  XECHO ;
  XECHO 5Exiting in 5 seconds.;
  ^PAUSE 5;
  //^QUIT;
};

### database routines
ALIAS lice.add (varname, data) {@ dbmctl(ADD $lice.fd "$tolower($varname)" $data)};
ALIAS lice.set (varname, data) {@ dbmctl(CHANGE $lice.fd "$tolower($varname)" $data)};
ALIAS lice.get (varname) {@ FUNCTION_RETURN = dbmctl(READ $lice.fd "$tolower($varname)")};
ALIAS lice.del (varname) {@ dbmctl(DELETE $lice.fd "$tolower($varname)")};

# check the db isn't still marked internally as open
IF (lice.get(db.status) == 1) {
  CLEAR;
  XECHO;
  XECHO [LiCe System Message];
  XECHO;
  XECHO Warning: Database marked open;
  XECHO;
  XECHO Are you using LiCe already?;
  XECHO;
  XECHO Continuing in 5 seconds...;
  PAUSE 5;
};

# mark database as open
@lice.set(db.status 1);

# read sets from the db and push them into place
ALIAS lice.readsets {
  # We sort the list of sets before loading to keep in sync with lice.sets format.
  # works around a bug where STATUS_NICKNAME being set before STATUS_FORMAT1 doesn't work correctly.
  FE ($sort($dbmctl(ALL_KEYS $lice.fd))) ls {
    @ :dbset = after(* $ls);
    @ :dbvalue = lice.get($ls);
    UNLESS ((strlen($dbset) == 0) || (dbvalue == [<unset>])) {
      //^SET $dbset $dbvalue;
    };
  };
};

ALIAS lice.readchanlog {
  FE ($dbmctl(ALL_KEYS $lice.fd)) ls {
    @ :data= after(! $ls);
    UNLESS (strlen($data) == 0) {
      ^ASSIGN Chanlog$(data) $lice.get($ls);
    };
  };
};

ALIAS lice.readignores {
  FE ($dbmctl(ALL_KEYS $lice.fd)) ls {
    @ :igid= after(| $ls);
    UNLESS (strlen($igid) == 0) {
      //^IGNORE $lice.get($ls);
    };
  };
};

ALIAS lice.readservers {
  FE ($dbmctl(ALL_KEYS $lice.fd)) ls {
    @ :sid= after(& $ls);
    UNLESS (strlen($sid) == 0) {
      //^SERVER -ADD $lice.get($ls);
    };
  };
};

ALIAS lice.saveservers {
  FE ($dbmctl(ALL_KEYS $lice.fd)) ls {
    @ :sid= after(& $ls);
    UNLESS (strlen($sid) == 0) {
      @lice.del($ls);
    };
  };
  FE ($serverctl(GMATCH *)) id {
    # work around epic5 bug - $serverctl(GMATCH *)) currently returns servers that have been deleted!
    IF (serverctl(GET $id NAME)) {
      @lice.add(&server$(id) $serverctl(GET $id FULLDESC));
    };
  };
};

ALIAS notify {
  //NOTIFY $*;
  @lice.set (lice.notify $notify());
};

# Auto save of servers
ALIAS SERVER {
  //SERVER $*;
  IF (([$0] =~ [-D*]) || ([$0] =~ [-U*])) {lice.saveservers};
};
^ON ^CONNECT * {^TIMER 5 {lice.saveservers}};

#tjh/12
