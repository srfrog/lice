#
#   IRC Script Program. For use with ircii-EPIC5 clients.
#   Copyright (C) 2000 SrfRoG (cag@codehack.com)
#
# ---------------------------------------------------------------------------
# lice.dbmctl written by tjh for LiCe5.2.0+ for EPIC5. tjh - tim@muppetz.com
#
# This file opens the database file in which variables are stored and creates
# some aliases to easily manage the variables in the DB.
# autosave of system settings is handled (mostly) by this file.
#
# http://lice.muppetz.com - LiCe5
# ---------------------------------------------------------------------------
#

IF (word(2 $loadinfo()) != [pf]) {
  LOAD -pf $word(1 $loadinfo());
  RETURN;
};

PACKAGE LiCe;

@ mkdir($lice.save_path);

# open database
@ lice.fd = dbmctl(OPEN STD $(lice.save_path)/lice.db);

# check we got the db open and if not, die.
IF (lice.fd == -1) {
  CLEAR;
  xECHO;
  XECHO [LiCe System Message];
  XECHO;
  XECHO Unable to open $(lice.save_path)/lice.db - Please check this path is valid!;
  XECHO ;
  XECHO This is a fatal error!;
  XECHO ;
  XECHO 5Exiting in 5 seconds.;
  ^PAUSE 5;
  //^QUIT;
};

### database routines
ALIAS lice.add (varname, data) {@ dbmctl(ADD $lice.fd "$tolower($varname)" $data)};
ALIAS lice.set (varname, data) {@ dbmctl(CHANGE $lice.fd "$tolower($varname)" $data)};
ALIAS lice.get (varname) {@ FUNCTION_RETURN = dbmctl(READ $lice.fd "$tolower($varname)")};
ALIAS lice.del (varname) {@ dbmctl(DELETE $lice.fd "$tolower($varname)")};

# read sets from the db and push them into place
ALIAS _lice.readsets {
  # We sort the list of sets before loading to keep in sync with lice.sets format.
  # works around a bug where STATUS_NICKNAME being set before STATUS_FORMAT1 doesn't work correctly.
  FE ($sort($dbmctl(ALL_KEYS $lice.fd))) ls {
    @ :dbset = after(* $ls);
    @ :dbvalue = lice.get($ls);
    UNLESS ((strlen($dbset) == 0) || (dbvalue == [<unset>])) {
      //^SET $dbset $dbvalue;
    };
  };
};

ALIAS _lice.readchanlog {
  FE ($dbmctl(ALL_KEYS $lice.fd)) ls {
    @ :data= after(! $ls);
    UNLESS (strlen($data) == 0) {
      ^ASSIGN Chanlog$(data) $lice.get($ls);
    };
  };
};

ALIAS _lice.readignores {
  FE ($dbmctl(ALL_KEYS $lice.fd)) ls {
    @ :igid= after(| $ls);
    UNLESS (strlen($igid) == 0) {
      //^IGNORE $lice.get($ls);
    };
  };
};

ALIAS _lice.readservers {
  FE ($dbmctl(ALL_KEYS $lice.fd)) ls {
    @ :sid= after(& $ls);
    UNLESS (strlen($sid) == 0) {
      //^SERVER -ADD $lice.get($ls);
    };
  };
};

ALIAS _lice.saveservers {
  FE ($dbmctl(ALL_KEYS $lice.fd)) ls {
    @ :sid= after(& $ls);
    UNLESS (strlen($sid) == 0) {
      @lice.del($ls);
    };
  };
  FE ($serverctl(GMATCH *)) id {
    # work around epic5 bug - $serverctl(GMATCH *)) currently returns servers that have been deleted!
    IF (serverctl(GET $id NAME)) {
      @lice.add(&server$(id) $serverctl(GET $id NAME):$serverctl(GET $id PORT):$serverctl(GET $id PASS):nickname=$serverctl(GET $id NICKNAME):$serverctl(GET $id GROUP):$serverctl(GET $id PROTOCOL));
    };
  };
};

ALIAS notify {
  //NOTIFY $*;
  @lice.set (lice.notify $notify());
};

ALIAS server {
  //SERVER $*;
  _lice.saveservers;
};

# Catch other server connections and add to list.
^ON ^SERVER_ESTABLISHED * {_lice.saveservers};

#tjh/11
